# -*- coding: utf-8 -*-
"""DA_GoodReads_100k_books (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18tYWW-VHIronIG0bTbJpWVrW16iXKDBg
"""

from google.colab import drive
drive.mount('/content/drive')

!cd /content/drive/MyDrive/Kaggle/
!ls /content/drive/MyDrive/Kaggle/

!pip install skimpy

!mkdir ~/.kaggle
!touch ~/.kaggle/kaggle.json

api_token = {"username":"mahimathakur","key":"7503a502a434f3f056a256ba01ffa25d"}

import json

with open('/root/.kaggle/kaggle.json', 'w') as file:
    json.dump(api_token, file)

!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets download -d mdhamani/goodreads-books-100k

from zipfile import ZipFile

zip = ZipFile('goodreads-books-100k.zip')
zip.extractall()

!pip install colorama

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image as im
from wordcloud import WordCloud, STOPWORDS, ImageColorGenerator
!pip install colorama
# %matplotlib inline

from colorama import Fore, Back, Style
red = Fore.RED
grn = Fore.GREEN
blu = Fore.BLUE
ylw = Fore.YELLOW
wht = Fore.WHITE
mag = Fore.MAGENTA

palette = sns.color_palette("bright",15)
sns.palplot(palette)
sns.set_palette("Paired")

import re
import numpy  as np
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
import plotly.colors as colors
from wordcloud import WordCloud
from sklearn.neighbors import NearestNeighbors
import warnings
warnings.filterwarnings("ignore")



!ls

data = pd.read_csv('GoodReads_100k_books.csv')
data[:50]

df = data

from skimpy import skim

skim(df)

data.isnull().sum()

def clean(feature):
    cleaned_feature = list()
    for feat in data[feature]:
        if len(feat.split(',')) > 1:
            temp = feat.split(',')
            for a in temp:
                cleaned_feature.append(a)
        else:
            cleaned_feature.append(feat)
    return cleaned_feature

def plot_distribution(data,feat,color,alpha=1):
    sns.set(font_scale=1);
    sns.displot(data[feat],color=color,kde=True,aspect=15/10,alpha = alpha,);
    print(f'{red}Max value of {feat} is {data[feat].max()}\n{blu}Min value of {feat} is {data[feat].min()}\n{grn}Std value of {feat} is {data[feat].std()}\n{ylw}Mean value of {feat} is {data[feat].mean()}\n{mag}Median value of {feat} is {data[feat].median()}')

all_authors = clean('author')
authors = pd.DataFrame(all_authors, columns = ['authors'])
author_counts = authors.value_counts()
authors['books_count'] = authors['authors'].apply(lambda x: author_counts[x])
sorted_authors = authors.sort_values(by='books_count',ascending=False)
sorted_authors = sorted_authors.drop_duplicates(['authors'])
sorted_authors = sorted_authors.reset_index(drop = True)

sorted_authors

# Python program to generate WordCloud

# importing all necessary modules
from wordcloud import WordCloud, STOPWORDS
import matplotlib.pyplot as plt
import pandas as pd

comment_words = ''
stopwords = set(STOPWORDS)

# iterate through the csv file
for author in sorted_authors.authors:

	# typecaste each val to string
	author = str(author)

	# split the value
	tokens = author.split()

	# Converts each token into lowercase
	for i in range(len(tokens)):
		tokens[i] = tokens[i].lower()

	comment_words += " ".join(tokens)+" "

wordcloud = WordCloud(width = 800, height = 800,
				background_color ='white',
				stopwords = stopwords,
				min_font_size = 10).generate(comment_words)

# plot the WordCloud image
plt.figure(figsize = (8, 8), facecolor = None)
plt.imshow(wordcloud)
plt.axis("off")
plt.tight_layout(pad = 0)

plt.show()





from wordcloud import WordCloud, STOPWORDS, ImageColorGenerator

data['genre'] = data['genre'].fillna('None')
all_genres = clean('genre')
genres = pd.DataFrame(all_genres, columns = ['genres'])
genre_counts = genres.value_counts()
genres['genre_count'] = genres['genres'].apply(lambda x: genre_counts[x])
sorted_genres = genres.sort_values(by='genre_count',ascending=False)
sorted_genres = sorted_genres.drop_duplicates(['genres'])
sorted_genres = sorted_genres.reset_index(drop = True)

sorted_genres

# Python program to generate WordCloud

# importing all necessary modules
# from wordcloud import WordCloud, STOPWORDS
# import matplotlib.pyplot as plt
# import pandas as pd

comment_words = ''
stopwords = set(STOPWORDS)

# iterate through the csv file
for genre in sorted_genres.genres:

	# typecaste each val to string
	genre = str(genre)

	# split the value
	tokens = genre.split()

	# Converts each token into lowercase
	for i in range(len(tokens)):
		tokens[i] = tokens[i].lower()

	comment_words += " ".join(tokens)+" "

wordcloud = WordCloud(width = 800, height = 800,
				background_color ='white',
				stopwords = stopwords,
				min_font_size = 10).generate(comment_words)

# plot the WordCloud image
plt.figure(figsize = (8, 8), facecolor = None)
plt.imshow(wordcloud)
plt.axis("off")
plt.tight_layout(pad = 0)

plt.show()

plot_distribution(sorted_genres[:120],'genre_count','lime',0.4);

data.rating.mean()

# What are the most frequently repeated books on the list? (Top 20 books)
top_20_books = data['title'].value_counts()[:20]

# Define a color palette with enough unique colors
color_palette = colors.qualitative.Plotly

# Create a list of distinct colors for each bar
bar_colors = [color_palette[i % len(color_palette)] for i in range(len(top_20_books))]

# Create a Plotly bar plot
fig = go.Figure(data=[go.Bar(
    x=top_20_books,
    y=data.index,
    orientation='h',
    marker=dict(color=bar_colors)  # Set the bar colors using the list of colors
)])

# Update the layout with dark background and white font
fig.update_layout(
    plot_bgcolor='rgb(17, 17, 17)',  # Dark background color
    paper_bgcolor='rgb(17, 17, 17)',  # Dark background color
    font=dict(color='white'),  # White font color
    title="Most Occurring Books",
    xaxis_title="Number of occurrences",
    yaxis_title="Books"
)

# Show the plot
fig.show()

top_20_most_rated_books = data.sort_values('totalratings', ascending=False).head(20)

# Define the number of bars and obtain a color palette with enough unique colors
num_bars = len(top_20_most_rated_books)
color_palette = colors.qualitative.Set3

# Create a list of distinct colors for each bar
bar_colors = color_palette[:num_bars]

# Create a Plotly bar plot
fig = go.Figure(data=[go.Bar(
    x=top_20_most_rated_books['totalratings'],
    y=data['title'],
    orientation='h',
    marker=dict(color=bar_colors)  # Set the bar colors using the list of colors
)])

# Update the layout with dark background and white font
fig.update_layout(
    plot_bgcolor='rgb(17, 17, 17)',  # Dark background color
    paper_bgcolor='rgb(17, 17, 17)',  # Dark background color
    font=dict(color='white'),  # White font color
    title="Top 20 Most Rated Books",
    xaxis_title="Number of Ratings",
    yaxis_title="Book Title"
)

# Show the plot
fig.show()

top_rated_books = data[data['rating'] > 3.7]
top_rated_books = top_rated_books.sort_values(by='rating', ascending=False).head(20)

top_rated_books

top_books = data[data['totalratings'] > 2990]
top_books = top_books.sort_values(by='totalratings', ascending=False).head(20)

top_books.rating.mean()

top_reviewed_rated = top_books[top_books['rating'] > 4.0]
top_reviewed_rated = top_books.sort_values(by='rating', ascending=False).head(20)

top_reviewed_rated.head()

sns.set(style="darkgrid")
plt.figure(figsize=(10, 10))

color = sns.color_palette("Set2")
ax = sns.barplot(x="rating", y="title", data=top_reviewed_rated, palette=color)

for i in ax.patches:
    ax.text(i.get_width() + .05, i.get_y() + 0.5, str(i.get_width()), fontsize = 10, color = 'k')
plt.show()





"""So Top Rated and Reviewed Books fall into which category??"""

# Python program to generate WordCloud

# importing all necessary modules
# from wordcloud import WordCloud, STOPWORDS
# import matplotlib.pyplot as plt
# import pandas as pd

comment_words = ''
stopwords = set(STOPWORDS)

# iterate through the csv file
for genre in top_reviewed_rated.genre:

	# typecaste each val to string
	genre = str(genre)

	# split the value
	tokens = genre.split()

	# Converts each token into lowercase
	for i in range(len(tokens)):
		tokens[i] = tokens[i].lower()

	comment_words += " ".join(tokens)+" "

wordcloud = WordCloud(width = 800, height = 800,
				background_color ='white',
				stopwords = stopwords,
				min_font_size = 10).generate(comment_words)

# plot the WordCloud image
plt.figure(figsize = (8, 8), facecolor = None)
plt.imshow(wordcloud)
plt.axis("off")
plt.tight_layout(pad = 0)

plt.show()

# Python program to generate WordCloud

# importing all necessary modules
# from wordcloud import WordCloud, STOPWORDS
# import matplotlib.pyplot as plt
# import pandas as pd

comment_words = ''
stopwords = set(STOPWORDS)

# iterate through the csv file
for author in top_reviewed_rated.author:

	# typecaste each val to string
	auyhor = str(author)

	# split the value
	tokens = author.split()

	# Converts each token into lowercase
	for i in range(len(tokens)):
		tokens[i] = tokens[i].lower()

	comment_words += " ".join(tokens)+" "

wordcloud = WordCloud(width = 800, height = 800,
				background_color ='white',
				stopwords = stopwords,
				min_font_size = 10).generate(comment_words)

# plot the WordCloud image
plt.figure(figsize = (8, 8), facecolor = None)
plt.imshow(wordcloud)
plt.axis("off")
plt.tight_layout(pad = 0)

plt.show()

most_books = data.groupby('author')['title'].count().reset_index().sort_values('title', ascending=False).head(20)
most_books.head()

# Group the dataframe by authors and count the number of titles for each author
most_books = data.groupby('author')['title'].count().reset_index().sort_values('title', ascending=False).head(20)

# Create a Plotly bar plot
fig = go.Figure(data=[go.Bar(
    x=most_books['title'],
    y=most_books['author'],
    orientation='h',
    marker=dict(color=colors.qualitative.Pastel)  # Set the bar colors using a qualitative color palette
)])

# Update the layout with dark background and white font
fig.update_layout(
    plot_bgcolor='rgb(17, 17, 17)',  # Dark background color
    paper_bgcolor='rgb(17, 17, 17)',  # Dark background color
    font=dict(color='white'),  # White font color
    title="Top 20 Authors with Most Books",
    xaxis_title="Total Number of Books",
    yaxis_title="Authors"
)

# Add labels to the bars
for i, val in enumerate(most_books['title']):
    fig.add_annotation(
        x=val + 0.3,
        y=most_books['author'].iloc[i],
        text=str(val),
        font=dict(color='black', size=10),
        showarrow=False
    )

# Show the plot
fig.show()

## Top 20 Authors with Highest Rated Books

high_rated_author = data[data['rating'] >= 4.3]
high_rated_author = high_rated_author.groupby('author')['title'].count().reset_index().sort_values('title', ascending=False).head(20)

# Define the number of bars and obtain a color palette with enough unique colors
num_bars = len(high_rated_author)
color_palette = colors.qualitative.Set2

# Create a list of distinct colors for each bar
bar_colors = color_palette[:num_bars]

# Create a Plotly bar plot
fig = go.Figure(data=[go.Bar(
    x=high_rated_author['title'],
    y=high_rated_author['author'],
    orientation='h',
    marker=dict(color=bar_colors)  # Set the bar colors using the list of colors
)])

# Update the layout with dark background and white font
fig.update_layout(
    plot_bgcolor='rgb(17, 17, 17)',  # Dark background color
    paper_bgcolor='rgb(17, 17, 17)',  # Dark background color
    font=dict(color='white'),  # White font color
    title="Top 20 Authors with Highest Rated Books",
    xaxis_title="Number of Books",
    yaxis_title="Authors"
)

# Show the plot
fig.show()

rating = data['rating'].astype(float)

fig = px.histogram(rating, histnorm='density')

fig.update_layout(
    plot_bgcolor='rgb(17, 17, 17)',  # Dark background color
    paper_bgcolor='rgb(17, 17, 17)',  # Dark background color
    font=dict(color='white'),  # White font color
    title="Distribution of Average Ratings",
    xaxis_title="Average Rating",
    yaxis_title="Density"
)

fig.show()











"""Top 20 Top Voted Books"""

top_vote = top_reviewed_rated.sort_values(by='rating', ascending=False).head(20)

top_vote.head(1)

sns.set(style="darkgrid")
plt.figure(figsize=(10, 10))

color = sns.color_palette("Set2")
ax = sns.barplot(x="totalratings", y="title", data=top_vote, palette=color)

for i in ax.patches:
    ax.text(i.get_width() + .05, i.get_y() + 0.5, str(i.get_width()), fontsize = 10, color = 'k')
plt.show()



# Python program to generate WordCloud

# importing all necessary modules
# from wordcloud import WordCloud, STOPWORDS
# import matplotlib.pyplot as plt
# import pandas as pd

comment_words = ''
stopwords = set(STOPWORDS)

# iterate through the csv file
for title in top_vote.title:

	# typecaste each val to string
	title = str(title)

	# split the value
	tokens = title.split()

	# Converts each token into lowercase
	for i in range(len(tokens)):
		tokens[i] = tokens[i].lower()

	comment_words += " ".join(tokens)+" "

wordcloud = WordCloud(width = 800, height = 800,
				background_color ='white',
				stopwords = stopwords,
				min_font_size = 10).generate(comment_words)

# plot the WordCloud image
plt.figure(figsize = (8, 8), facecolor = None)
plt.imshow(wordcloud)
plt.axis("off")
plt.tight_layout(pad = 0)

plt.show()

# Python program to generate WordCloud

# importing all necessary modules
# from wordcloud import WordCloud, STOPWORDS
# import matplotlib.pyplot as plt
# import pandas as pd

comment_words = ''
stopwords = set(STOPWORDS)

# iterate through the csv file
for author in top_vote.author:

	# typecaste each val to string
	author = str(author)

	# split the value
	tokens = author.split()

	# Converts each token into lowercase
	for i in range(len(tokens)):
		tokens[i] = tokens[i].lower()

	comment_words += " ".join(tokens)+" "

wordcloud = WordCloud(width = 800, height = 800,
				background_color ='white',
				stopwords = stopwords,
				min_font_size = 10).generate(comment_words)

# plot the WordCloud image
plt.figure(figsize = (8, 8), facecolor = None)
plt.imshow(wordcloud)
plt.axis("off")
plt.tight_layout(pad = 0)

plt.show()

# Group the dataframe by authors and count the number of titles for each author
most_books = data.groupby('author')['title'].count().reset_index().sort_values('title', ascending=False).head(20)

# Create a Plotly bar plot
fig = go.Figure(data=[go.Bar(
    x=most_books['title'],
    y=most_books['author'],
    orientation='h',
    marker=dict(color=colors.qualitative.Pastel)  # Set the bar colors using a qualitative color palette
)])

# Update the layout with dark background and white font
fig.update_layout(
    plot_bgcolor='rgb(17, 17, 17)',  # Dark background color
    paper_bgcolor='rgb(17, 17, 17)',  # Dark background color
    font=dict(color='white'),  # White font color
    title="Top 20 Authors with Most Books",
    xaxis_title="Total Number of Books",
    yaxis_title="Authors"
)

# Add labels to the bars
for i, val in enumerate(most_books['title']):
    fig.add_annotation(
        x=val + 0.3,
        y=most_books['author'].iloc[i],
        text=str(val),
        font=dict(color='black', size=10),
        showarrow=False
    )

# Show the plot
fig.show()







!pip install plotly==5.16.0

# plotly standard imports
import plotly.graph_objs as go
#

# Cufflinks wrapper on plotly
import cufflinks

# Data science imports
import pandas as pd
import numpy as np

# Options for pandas
pd.options.display.max_columns = 30

# Display all cell outputs
from IPython.core.interactiveshell import InteractiveShell

InteractiveShell.ast_node_interactivity = "all"

from plotly.offline import iplot

cufflinks.go_offline()

# Set global theme
cufflinks.set_config_file(world_readable=True, theme="pearl")

df = top_reviewed_rated.sort_values("rating", ascending = False)
#fig = go.Figure(data=go.Scatter(x=df['rating'], y=data['title'], mode='markers', marker=dict(color='red')))

df.iplot(
    x="rating",
    y="title",
    xTitle="Rating",
    yTitle="Title",
    text="title",
    mode="markers",
    title="Book Title vs Rating",
)



df = top_reviewed_rated.sort_values("rating", ascending = False)

#df = top_reviewed_rated.sort_values("Country", ascending = False)

ax = sns.barplot(x="rating", y="title", data=top_reviewed_rated, palette=color)

fig = go.Figure(data=go.Scatter(x=df['rating'], y=data['title'], mode='markers', marker=dict(color='red')))
#fig = px.Scatter(
    #df, y='title', x='rating', color='title', size='rating', size_max=20,
    #color_continuous_scale = px.colors.sequential.RdBu)
fig.update_layout(
        paper_bgcolor="white",
        plot_bgcolor="white",
     )
# #fig = px.colors.sequential.swatches_continuous()
fig.update_yaxes(showgrid=True, gridwidth=1, gridcolor='LightGray')
fig.update_xaxes(showgrid=True, gridwidth=1, gridcolor='LightGray')
fig.update_layout(height=500, width=1000)
fig.update_coloraxes(colorbar=dict(title='Title'))
fig.update_traces(marker=dict(sizeref=0.09))
fig.update_yaxes(title="Title")
fig.update_xaxes(title='Rating')
fig.update_layout(showlegend=True)
fig.show()

N = 100000
fig = go.Figure(data=go.Scatter(x=data['rating'], y=data['title'], mode='markers', marker=dict(color='red')))

# fig = go.Figure(data=go.Scatter(
#     x=[1, 2, 3, 4],
#     y=[10, 11, 12, 13],
#     mode='markers',
#     marker=dict(size=[40, 60, 80, 100],
#                 color=[0, 1, 2, 3])
# ))

fig.show()

list(set(top_rated_books['title'].values) - set(top_reviewed_rated['title'].values))

list(set(top_vote['title'].values) - set(top_rated_books['title'].values))

data.columns

ax = sns.relplot(data=data, x="rating",y="totalratings" ,color = '#95a3c3', sizes=(100, 200), height=7, marker='o')

new_data = data.copy()

def fun_only_author(text):
    arlen = text.split('/')
    return arlen[0]

new_data['only_author'] = new_data['author'].apply(lambda x : fun_only_author(x))

total_rating = new_data.drop_duplicates(subset=['only_author', 'title'], keep='first')
total_rating = total_rating.groupby(by=['only_author']).agg({'rating': ['sum']})
total_rating.columns = ['totalratings']
total_rating.reset_index(inplace=True)
total_rating = total_rating.sort_values(by=['totalratings'], ascending=False)
total_rating

total_book = new_data.groupby(by=['only_author']).agg({'title': ['nunique']})
total_book.columns = ['total_book']
total_book.reset_index(inplace=True)
total_book = total_book.sort_values(by=['total_book'], ascending=False)
total_book

avg_author = pd.merge(total_book, total_rating, on='only_author', how='outer')
avg_author['rating'] = round(avg_author['totalratings'] / avg_author['total_book'], 2)
avg_author = avg_author[avg_author['total_book'] > 26]
avg_author = avg_author.sort_values(by=['rating'], ascending=False)
avg_author

new_data.columns

total_vote = new_data.drop_duplicates(subset=['only_author', 'title'], keep='first')
total_vote.reset_index(inplace=True)
total_vote = total_vote[['only_author', 'title', 'rating', 'totalratings']]
total_vote

"""Average Rating"""

C = total_vote.rating.mean()
C

m = total_vote.totalratings.quantile(0.9)
m

k = total_vote.totalratings.quantile(0.8)
k

total_vote = total_vote[total_vote['totalratings'] >= m]
total_vote.head()

def weighted_rating(x, m=m, C=C):
    v = x['totalratings']
    R = x['rating']
    return (v/(v+m) * R) + (m/(m+v) * C)

total_vote['score'] = total_vote.apply(weighted_rating, axis=1)

total_vote = total_vote.sort_values(by='score', ascending=False).head(20)
total_vote.head()

"""Top 20 Weighted Rating Books"""

sns.set(style="darkgrid")
plt.figure(figsize=(10, 10))

color = sns.color_palette("Set2")
ax = sns.barplot(x="score", y="title", data=total_vote, palette=color)

for i in ax.patches:
    ax.text(i.get_width() + .05, i.get_y() + 0.5, str(i.get_width()), fontsize = 10, color = 'k')
plt.title("Top 20 Weighted Rating Books")
plt.show()

"""Most books of an author"""

sns.set(style="darkgrid")
plt.figure(figsize=(10, 10))

color = sns.color_palette("Set2")
ax = sns.barplot(x="total_book", y="only_author", data=avg_author, palette=color)

for i in ax.patches:
    ax.text(i.get_width() + .05, i.get_y() + 0.5, str(i.get_width()), fontsize = 10, color = 'k')
plt.show()

sns.set(style="darkgrid")
plt.figure(figsize=(10, 10))

color = sns.color_palette("Set2")
ax = sns.barplot(x="rating", y="only_author", data=avg_author, palette=color)

for i in ax.patches:
    ax.text(i.get_width() + .05, i.get_y() + 0.5, str(i.get_width()), fontsize = 10, color = 'k')
plt.show()

data.columns

top_pages = data.sort_values(by='pages', ascending=False).head(20)

sns.set(style="darkgrid")
plt.figure(figsize=(10, 10))

color = sns.color_palette("Set2")
ax = sns.barplot(x="pages", y="title", data=top_pages, palette=color)

for i in ax.patches:
    ax.text(i.get_width() + .05, i.get_y() + 0.5, str(i.get_width()), fontsize = 10, color = 'k')
plt.show()

"""Relationship between rating and page"""

ax = sns.relplot(data=data, x="rating", y="pages", color = '#95a3c3', sizes=(100, 200), height=7, marker='o')

"""Relationship between pages and totalratings"""

ax = sns.relplot(data=data, x="pages", y="totalratings", color = '#95a3c3', sizes=(100, 200), height=7, marker='o')

title_value = data.title.unique()

from wordcloud import WordCloud, STOPWORDS, ImageColorGenerator

len(new_data.only_author.unique())

new_data.loc[ (new_data['rating'] >= 0) & (new_data['rating'] <= 1), 'rating_between'] = "between_0_to_1"
new_data.loc[ (new_data['rating'] > 1) & (new_data['rating'] <= 2), 'rating_between'] = "between_1_to_2"
new_data.loc[ (new_data['rating'] > 2) & (new_data['rating'] <= 3), 'rating_between'] = "between_2_to_3"
new_data.loc[ (new_data['rating'] > 3) & (new_data['rating'] <= 4), 'rating_between'] = "between_3_to_4"
new_data.loc[ (new_data['rating'] > 4) & (new_data['rating'] <= 5), 'rating_between'] = "between_4_to_5"

new_data.head(2)

trial = new_data[['rating', 'totalratings']]
data_model = np.asarray([np.asarray(trial['rating']), np.asarray(trial['totalratings'])]).T
data_model

from sklearn.cluster import KMeans

# Elbow Method

score = []
x = data_model
for cluster in range(1,41):
    kmeans = KMeans(n_clusters = cluster, init="k-means++", random_state=40)
    kmeans.fit(x)
    score.append(kmeans.inertia_)

# plotting the score
plt.figure(figsize=(15, 10))
plt.plot(range(1,41), score)
plt.title('The Elbow Method')
# plt.xlabel('no of clusters')
# plt.ylabel('wcss')
plt.show()

rating_between_df = new_data['rating_between'].str.get_dummies(sep=",")
rating_between_df.head()



engine_features = pd.concat([rating_between_df,new_data['rating'], new_data['totalratings']], axis=1)
engine_features.head()

from sklearn.preprocessing import MinMaxScaler
min_max_scaler = MinMaxScaler()
engine_features = min_max_scaler.fit_transform(engine_features)

from sklearn import neighbors

engine_model = neighbors.NearestNeighbors(n_neighbors=10, algorithm='ball_tree')

engine_model.fit(engine_features)

dist, idlist = engine_model.kneighbors(engine_features)

def book_recommendation_engine(book_name):
    book_list_name = []
    book_id = new_data[new_data['title'] == book_name].index
    book_id = book_id[0]
#     print('book_id', book_id)
    for newid in idlist[book_id]:
#         print(newid)
        book_list_name.append(new_data.loc[newid].title)
#         print(new_data.loc[newid].title)
    return book_list_name

book_list_name = book_recommendation_engine('Harry Potter and the Deathly Hallows')
book_list_name





















